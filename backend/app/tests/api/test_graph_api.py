# backend/app/tests/api/test_graph_api.py
import pytest
from httpx import AsyncClient
from typing import Dict, Any
import uuid

# Assuming your FastAPI app instance is accessible for testing
# If main.py defines `app`, and tests are run from project root, this might work:
from backend.app.main import app  # Main FastAPI app instance
from backend.app.core.config import settings
from backend.app.services.graph_service import GraphDatabaseService, get_graph_service

# Test data IDs
API_TEST_BRIDGE_ID = f"api-test-bridge-{uuid.uuid4()}"
API_TEST_COMPONENT_ID = f"api-test-comp-{uuid.uuid4()}"
API_TEST_MATERIAL_ID = f"api-test-mat-{uuid.uuid4()}"

# Helper to clean up test data via API or service after tests.
# For API tests, it's often better to ensure idempotency or use a clean test DB.
# Here, we might use the service directly for cleanup for simplicity.
def cleanup_test_node_via_service(node_label: str, node_id: str):
    # This assumes get_graph_service() can provide a service instance
    # independent of FastAPI's dependency injection for cleanup purposes.
    # In a real test setup, you might have a direct DB connection for cleanup.
    try:
        service = get_graph_service() # Relies on global driver being init
        service.delete_node(node_label, node_id)
        print(f"Cleaned up test node via service: {node_label} {node_id}")
    except Exception as e:
        print(f"Error during service cleanup for {node_label} {node_id}: {e}")


@pytest.fixture(scope="module")
async def async_client() -> AsyncClient:
    """Fixture to create an AsyncClient for making API requests."""
    # Base URL should match your running app if testing against a live server.
    # For integrated tests with TestClient or AsyncClient, it's relative to app.
    async with AsyncClient(app=app, base_url=f"http://127.0.0.1:8000{settings.API_PREFIX}") as client:
        yield client

# --- Test Cases for Graph API Endpoints ---

@pytest.mark.asyncio
async def test_api_initialize_database(async_client: AsyncClient):
    """测试 /graph/initialize API 端点。"""
    response = await async_client.post("/graph/initialize")
    assert response.status_code == 200
    json_response = response.json()
    assert json_response["message"] == "Database initialization process finished."
    assert "details" in json_response
    assert "Bridge_id_unique" in json_response["details"]
    assert "Failed" not in json_response["details"]["Bridge_id_unique"]


# --- Node CRUD API Tests ---
@pytest.mark.asyncio
async def test_api_create_bridge(async_client: AsyncClient):
    """测试创建桥梁节点的API: POST /graph/nodes/Bridge"""
    cleanup_test_node_via_service("Bridge", API_TEST_BRIDGE_ID) # Cleanup before

    bridge_payload = {
        "name": "API Test Bridge",
        "location": "API Test Location",
        "bridge_type": "API Arch",
        "additional_props": {"status": "testing"}
    }
    # Note: The API expects BridgeCreateSchema which doesn't include 'id'.
    # The 'id' is generated by the server (Pydantic default_factory in BridgeModel).

    response = await async_client.post("/graph/nodes/Bridge", json=bridge_payload)
    assert response.status_code == 201, response.text
    created_bridge = response.json()

    assert created_bridge["name"] == "API Test Bridge"
    assert "id" in created_bridge # Server should assign an ID
    global test_created_bridge_id # Store for later tests in this module
    test_created_bridge_id = created_bridge["id"]

    assert created_bridge["additional_props"]["status"] == "testing"

    # Verify by fetching
    get_response = await async_client.get(f"/graph/nodes/Bridge/{test_created_bridge_id}")
    assert get_response.status_code == 200
    fetched_bridge = get_response.json()
    assert fetched_bridge["name"] == "API Test Bridge"

    # Cleanup after this specific test function if not relying on module-level cleanup
    # cleanup_test_node_via_service("Bridge", test_created_bridge_id)


@pytest.mark.asyncio
async def test_api_get_all_bridges(async_client: AsyncClient):
    """测试获取所有桥梁节点的API: GET /graph/nodes/Bridge"""
    # Ensure at least one bridge (created in previous test if run in order, or create one here)
    # For robustness, tests should be independent. Create a bridge here.
    temp_bridge_id = f"api-temp-bridge-getall-{uuid.uuid4()}"
    cleanup_test_node_via_service("Bridge", temp_bridge_id)

    # Use the service to create directly to simplify test setup for GET all
    service = get_graph_service()
    from backend.app.models.graph_models import BridgeModel
    service.create_node("Bridge", BridgeModel(id=temp_bridge_id, name="Bridge for GET ALL test"))

    response = await async_client.get("/graph/nodes/Bridge?limit=5")
    assert response.status_code == 200
    bridges = response.json()
    assert isinstance(bridges, list)
    assert len(bridges) > 0 # Assuming some bridges exist (at least the one created)
    assert any(b["id"] == temp_bridge_id for b in bridges)

    cleanup_test_node_via_service("Bridge", temp_bridge_id)


@pytest.mark.asyncio
async def test_api_update_bridge(async_client: AsyncClient):
    """测试更新桥梁节点的API: PUT /graph/nodes/Bridge/{node_id}"""
    # Create a bridge to update
    bridge_to_update_id = f"api-bridge-update-{uuid.uuid4()}"
    cleanup_test_node_via_service("Bridge", bridge_to_update_id)

    service = get_graph_service()
    from backend.app.models.graph_models import BridgeModel, BridgeCreateSchema
    # Create using schema, then construct full model for service
    create_schema = BridgeCreateSchema(name="Bridge to Update Original", location="Original Location")
    full_model = BridgeModel(**create_schema.dict(), id=bridge_to_update_id) # Pydantic V1
    service.create_node("Bridge", full_model)

    update_payload = {
        "name": "API Bridge Updated Name",
        "location": "Updated Location",
        "additional_props": {"version": 2}
    } # This matches BridgeUpdateSchema

    response = await async_client.put(f"/graph/nodes/Bridge/{bridge_to_update_id}", json=update_payload)
    assert response.status_code == 200, response.text
    updated_bridge = response.json()

    assert updated_bridge["id"] == bridge_to_update_id
    assert updated_bridge["name"] == "API Bridge Updated Name"
    assert updated_bridge["location"] == "Updated Location"
    assert updated_bridge["additional_props"]["version"] == 2

    cleanup_test_node_via_service("Bridge", bridge_to_update_id)


@pytest.mark.asyncio
async def test_api_delete_bridge(async_client: AsyncClient):
    """测试删除桥梁节点的API: DELETE /graph/nodes/Bridge/{node_id}"""
    bridge_to_delete_id = f"api-bridge-delete-{uuid.uuid4()}"
    cleanup_test_node_via_service("Bridge", bridge_to_delete_id)

    service = get_graph_service()
    from backend.app.models.graph_models import BridgeModel, BridgeCreateSchema
    create_schema = BridgeCreateSchema(name="Bridge to Delete")
    full_model = BridgeModel(**create_schema.dict(), id=bridge_to_delete_id)
    service.create_node("Bridge", full_model)

    response = await async_client.delete(f"/graph/nodes/Bridge/{bridge_to_delete_id}")
    assert response.status_code == 200, response.text # API returns 200 with message
    assert response.json()["message"].startswith("Bridge node with ID")

    # Verify deletion by trying to get it
    get_response = await async_client.get(f"/graph/nodes/Bridge/{bridge_to_delete_id}")
    assert get_response.status_code == 404

    # Test deleting non-existent node via API
    non_existent_id = f"api-bridge-non-existent-{uuid.uuid4()}"
    delete_response_404 = await async_client.delete(f"/graph/nodes/Bridge/{non_existent_id}")
    assert delete_response_404.status_code == 404


# --- Relationship API Tests ---
@pytest.mark.asyncio
async def test_api_create_relationship(async_client: AsyncClient):
    """测试创建关系的API: POST /graph/relationships"""
    # Setup: Create two nodes to connect
    b_id_rel = f"api-bridge-for-rel-{uuid.uuid4()}"
    c_id_rel = f"api-comp-for-rel-{uuid.uuid4()}"
    cleanup_test_node_via_service("Bridge", b_id_rel)
    cleanup_test_node_via_service("Component", c_id_rel)

    service = get_graph_service()
    from backend.app.models.graph_models import BridgeModel, ComponentModel
    service.create_node("Bridge", BridgeModel(id=b_id_rel, name="Rel Test Bridge"))
    service.create_node("Component", ComponentModel(id=c_id_rel, name="Rel Test Component"))

    rel_payload = {
        "start_node_label": "Bridge",
        "start_node_id": b_id_rel,
        "end_node_label": "Component",
        "end_node_id": c_id_rel,
        "rel_type": "API_HAS_COMPONENT",
        "properties": {"test_rel_prop": "value123"}
    }
    response = await async_client.post("/graph/relationships", json=rel_payload)
    assert response.status_code == 201, response.text
    created_rel = response.json() # Should match RelationshipResponse

    assert created_rel["type"] == "API_HAS_COMPONENT"
    assert created_rel["start_node_id"] == b_id_rel
    assert created_rel["end_node_id"] == c_id_rel
    assert created_rel["properties"]["test_rel_prop"] == "value123"
    assert "id" in created_rel # Internal Neo4j relationship ID

    # Verify by fetching relationships of the start node
    get_rels_response = await async_client.get(f"/graph/nodes/Bridge/{b_id_rel}/relationships?rel_type=API_HAS_COMPONENT")
    assert get_rels_response.status_code == 200
    rels_list = get_rels_response.json()
    assert len(rels_list) >= 1
    assert any(r["end_node_id"] == c_id_rel and r["type"] == "API_HAS_COMPONENT" for r in rels_list)

    cleanup_test_node_via_service("Bridge", b_id_rel)
    cleanup_test_node_via_service("Component", c_id_rel)


# --- Batch Import API Test ---
@pytest.mark.asyncio
async def test_api_batch_import(async_client: AsyncClient):
    """测试批量导入API: POST /graph/import"""
    b_id_batch = f"api-batch-b-{uuid.uuid4()}"
    c_id_batch = f"api-batch-c-{uuid.uuid4()}"
    cleanup_test_node_via_service("Bridge", b_id_batch)
    cleanup_test_node_via_service("Component", c_id_batch)

    import_payload = {
        "nodes": [
            {"label": "Bridge", "properties": {"id": b_id_batch, "name": "API Batch Bridge"}},
            {"label": "Component", "properties": {"id": c_id_batch, "name": "API Batch Component"}},
        ],
        "relationships": [{
            "start_node_label": "Bridge", "start_node_id": b_id_batch,
            "end_node_label": "Component", "end_node_id": c_id_batch,
            "rel_type": "API_BATCH_REL",
            "properties": {"source": "api_batch"}
        }]
    }
    response = await async_client.post("/graph/import", json=import_payload)
    assert response.status_code == 200, response.text
    import_results = response.json()

    assert import_results["message"] == "Batch import successful."
    # Depending on MERGE or CREATE logic in service, counts might vary if nodes existed.
    # Let's assume create logic or clean slate.
    assert import_results["nodes_created"] >= 0 # Can be 0 if MERGE found them
    assert import_results["relationships_created"] == 1

    # Verify by fetching one of the nodes
    get_bridge_resp = await async_client.get(f"/graph/nodes/Bridge/{b_id_batch}")
    assert get_bridge_resp.status_code == 200
    assert get_bridge_resp.json()["name"] == "API Batch Bridge"

    cleanup_test_node_via_service("Bridge", b_id_batch)
    cleanup_test_node_via_service("Component", c_id_batch)


# --- Custom Query API Test ---
@pytest.mark.asyncio
async def test_api_custom_read_query(async_client: AsyncClient):
    """测试自定义只读查询API: POST /graph/query"""
    # Setup: Create a node to query
    mat_id_query = f"api-query-mat-{uuid.uuid4()}"
    cleanup_test_node_via_service("Material", mat_id_query)
    service = get_graph_service()
    from backend.app.models.graph_models import MaterialModel
    service.create_node("Material", MaterialModel(id=mat_id_query, name="Query Test Material", material_type="Steel"))

    query_payload = {
        "query": "MATCH (m:Material {id: $mat_id}) RETURN m.name AS name, m.material_type AS type",
        "parameters": {"mat_id": mat_id_query}
    }
    response = await async_client.post("/graph/query", json=query_payload)
    assert response.status_code == 200, response.text
    query_results = response.json()

    assert len(query_results) == 1
    assert query_results[0]["name"] == "Query Test Material"
    assert query_results[0]["type"] == "Steel"

    # Test forbidden keyword
    forbidden_query_payload = {"query": "CREATE (n:Forbidden) RETURN n"}
    forbidden_response = await async_client.post("/graph/query", json=forbidden_query_payload)
    assert forbidden_response.status_code == 403 # Forbidden keyword

    cleanup_test_node_via_service("Material", mat_id_query)

@pytest.mark.asyncio
async def test_api_custom_write_query(async_client: AsyncClient):
    """测试自定义写查询API: POST /graph/query/write"""
    std_id_write_query = f"api-write-std-{uuid.uuid4()}"
    cleanup_test_node_via_service("Standard", std_id_write_query)

    query_payload = {
        "query": "CREATE (s:Standard {id: $std_id, name: $s_name, standard_code: 'API-WRITE-001'}) RETURN s",
        "parameters": {"std_id": std_id_write_query, "s_name": "API Write Test Standard"}
    }
    response = await async_client.post("/graph/query/write", json=query_payload)
    assert response.status_code == 200, response.text
    summary = response.json()

    assert summary["counters"]["nodes_created"] == 1

    # Verify by fetching
    get_std_resp = await async_client.get(f"/graph/nodes/Standard/{std_id_write_query}")
    assert get_std_resp.status_code == 200
    assert get_std_resp.json()["standard_code"] == "API-WRITE-001"

    cleanup_test_node_via_service("Standard", std_id_write_query)


# --- Specific Complex Query API Test ---
@pytest.mark.asyncio
async def test_api_get_bridge_components(async_client: AsyncClient):
    """测试获取桥梁构件的特定API: GET /graph/bridges/{bridge_id}/components"""
    b_id_complex = f"api-complex-b-{uuid.uuid4()}"
    c1_id_complex = f"api-complex-c1-{uuid.uuid4()}"
    c2_id_complex = f"api-complex-c2-{uuid.uuid4()}"
    cleanup_test_node_via_service("Bridge", b_id_complex)
    cleanup_test_node_via_service("Component", c1_id_complex)
    cleanup_test_node_via_service("Component", c2_id_complex)

    service = get_graph_service()
    from backend.app.models.graph_models import BridgeModel, ComponentModel, RelationshipData
    service.create_node("Bridge", BridgeModel(id=b_id_complex, name="Complex Query Bridge"))
    service.create_node("Component", ComponentModel(id=c1_id_complex, name="Complex Comp 1"))
    service.create_node("Component", ComponentModel(id=c2_id_complex, name="Complex Comp 2"))

    service.create_relationship(RelationshipData(
        start_node_label="Bridge", start_node_id=b_id_complex,
        end_node_label="Component", end_node_id=c1_id_complex,
        rel_type="HAS_COMPONENT"
    ))
    service.create_relationship(RelationshipData(
        start_node_label="Bridge", start_node_id=b_id_complex,
        end_node_label="Component", end_node_id=c2_id_complex,
        rel_type="HAS_COMPONENT"
    ))

    response = await async_client.get(f"/graph/bridges/{b_id_complex}/components")
    assert response.status_code == 200, response.text
    components = response.json()

    assert len(components) == 2
    comp_ids_fetched = {c["id"] for c in components}
    assert c1_id_complex in comp_ids_fetched
    assert c2_id_complex in comp_ids_fetched

    cleanup_test_node_via_service("Bridge", b_id_complex)
    cleanup_test_node_via_service("Component", c1_id_complex)
    cleanup_test_node_via_service("Component", c2_id_complex)


# Final cleanup (optional, if tests create data not cleaned up by individual tests)
# @pytest.fixture(scope="session", autouse=True)
# def final_cleanup():
#     yield
#     # Code to run after all tests in the session
#     print("\nPerforming final cleanup of remaining test data...")
#     # Example: Delete all nodes starting with "api-test-" or "test-"
#     # This requires direct DB access or a special admin API endpoint.
#     # Be very careful with such operations on a shared DB.
#     try:
#         service = get_graph_service()
#         query = "MATCH (n) WHERE n.id STARTS WITH 'api-test-' OR n.id STARTS WITH 'test-' DETACH DELETE n"
#         service.execute_custom_write_query(query)
#         print("Final cleanup query executed.")
#     except Exception as e:
#         print(f"Error during final cleanup: {e}")
